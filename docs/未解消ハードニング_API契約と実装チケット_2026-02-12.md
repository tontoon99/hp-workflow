# 未解消ハードニング API契約と実装チケット（2026-02-12）

## 目的
未解消として残っている以下3点を、実装可能な契約に落とす。

1. idempotency永続保証
2. 承認ゲートのSSO/監査ログ統合
3. 返金・失敗イベントと送信の状態整合（最終ガード）

この仕様は `n8n/*.json` の現行設計を前提に、外部API側で不足している保証を補完する。

## 公式根拠（2026-02-12確認）
- Stripe: webhook署名検証と重複処理対策
  - https://docs.stripe.com/webhooks?lang=node
  - https://docs.stripe.com/webhooks/process-undelivered-events
  - https://docs.stripe.com/checkout/fulfillment
- Stripe: refund/charge/payment_intent 関連オブジェクト
  - https://docs.stripe.com/api/refunds/object
  - https://docs.stripe.com/api/charges/object
- n8n: Wait再開Webhookの認証設定
  - https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.wait/
  - https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.webhook/

## A. Idempotency永続保証（必須）

### A-1. API契約
`POST /billing/webhook-events/claim`

Request(JSON):
```json
{
  "event_id": "evt_...",
  "event_type": "checkout.session.completed",
  "company_id": "company-123",
  "checkout_session_id": "cs_...",
  "received_at": "2026-02-12T05:40:00.000Z"
}
```

Response(JSON):
```json
{
  "accepted": true,
  "event_id": "evt_...",
  "claim_version": 1
}
```
または
```json
{
  "accepted": false,
  "duplicate": true,
  "event_id": "evt_..."
}
```

`POST /analysis-events/claim` も同じ思想で統一する。

### A-2. 永続化要件
`billing_webhook_events` テーブル:
- `event_id` UNIQUE NOT NULL
- `status` ENUM(`claimed`,`processed`,`failed`)
- `event_type`, `company_id`, `checkout_session_id`, `claimed_at`, `processed_at`

`analysis_events` テーブル:
- `dedupe_key` UNIQUE NOT NULL
  - 推奨: `sha256(company_id + stripe_event_id + checkout_session_id)`
- `status` ENUM(`claimed`,`processed`,`failed`)

### A-3. 原子性
- Claim APIは単一トランザクションで完了する。
- `INSERT ... ON CONFLICT DO NOTHING` で衝突判定し、衝突時は `accepted=false` を返す。
- 500系では n8n 側を失敗にし、再実行時に重複抑止できること。

### A-4. 受け入れ条件
1. 同一 `event_id` を100並列で叩いて `accepted=true` は1回のみ。
2. DBに重複行が作られない。
3. 既処理イベント再送時に `accepted=false` で200応答。

## B. 承認ゲートのSSO/監査ログ統合（必須）

### B-1. 問題
現行は Wait再開時に `approver_id` をpayloadで受けるため、本人性がAPI境界で確定しない。

### B-2. 契約方針
外部公開は Wait再開URLを直接使わず、承認ゲートAPIを経由する。

`POST /approvals/{stage}/decide`
- `stage`: `R1|R2|R3|R4`
- 認証: SSO JWT（IdP発行）
- 認可: JWTの `sub` と `roles` を使用（`operator/director/production_lead/sales_lead`）

Request(JSON):
```json
{
  "company_id": "company-123",
  "decision": "approved",
  "approval_token": "generated-by-workflow"
}
```

Response(JSON):
```json
{
  "accepted": true,
  "approval_id": "apr_...",
  "forwarded_to_wait_resume": true
}
```

### B-3. サーバー内処理
1. SSO JWT検証（署名・期限・audience）
2. ステージ別RBAC検証
3. `approval_token` を一度だけ使用可能に検証（replay防止）
4. Wait再開URLへサーバー間リクエストで転送
5. `approval_audit_logs` に保存

`approval_audit_logs`:
- `approval_id` PK
- `company_id`, `stage`, `decision`
- `actor_sub`, `actor_role`
- `ip`, `user_agent`
- `token_hash`, `token_used_at`
- `result` (`accepted`/`rejected`/`blocked`)

### B-4. 受け入れ条件
1. JWTなしは401。
2. role不一致は403。
3. 同じ `approval_token` 再利用は409。
4. 監査ログに actor_sub, role, decision, timestamp が必ず残る。

## C. 返金・失敗イベントと送信整合（必須）

### C-1. 会社特定契約（既実装を補完）
`POST /billing/resolve-company-context`

入力優先順:
1. `company_id`（metadata）
2. `checkout_session_id`
3. `payment_intent_id`
4. `charge_id`
5. `refund_id -> charge_id/payment_intent_id`

Response(JSON):
```json
{
  "event_id": "evt_...",
  "company_id": "company-123",
  "resolved_by": "payment_intent_id",
  "confidence": 1
}
```
解決不能時:
```json
{
  "event_id": "evt_...",
  "company_id": null,
  "resolved_by": "none",
  "confidence": 0
}
```

### C-2. 送信の最終ガード契約
`POST /notifications/send-proposal-atomic`

Request(JSON):
```json
{
  "company_id": "company-123",
  "proposal_bundle_id": "pb_...",
  "request_id": "req_..."
}
```

Server内要件:
1. `company_records.payment_status == paid` をトランザクション内で検証。
2. 非`paid`なら送信せず `blocked_payment_state` を返す。
3. 送信成功時のみ `status=sent` をコミット。
4. `request_id` の重複送信防止（UNIQUE）。

Response(JSON):
```json
{
  "sent": false,
  "reason": "blocked_payment_state",
  "payment_status": "refunded"
}
```
または
```json
{
  "sent": true,
  "delivery_id": "del_..."
}
```

### C-3. 受け入れ条件
1. `refund.created` 後は送信APIが必ず拒否。
2. 同一 `request_id` の再送で二重送信されない。
3. 送信成功ログと `status=sent` が整合する。

## 実装チケット（優先順）

1. `SEC-101` Claim APIのDB一意制約・原子UPSERT実装
- 対象: billing service
- 成果物: migration, repository, integration test
- 工数: M

2. `SEC-102` analysis-events claimのdedupe_key統一
- 対象: analysis service
- 成果物: dedupe仕様、API修正、並列テスト
- 工数: S

3. `SEC-103` 承認ゲートAPI（SSO JWT + RBAC）実装
- 対象: approval gateway
- 成果物: `/approvals/{stage}/decide`
- 工数: M

4. `SEC-104` approval tokenワンタイム化
- 対象: approval gateway + store
- 成果物: token state table, replay防止
- 工数: S

5. `SEC-105` 承認監査ログの永続化と検索API
- 対象: approval gateway
- 成果物: `approval_audit_logs`, GET API
- 工数: S

6. `SEC-106` 会社特定API（refund/charge/pi逆引き）強化
- 対象: billing service
- 成果物: resolver実装、Stripe API fallback
- 工数: M

7. `SEC-107` 送信原子化API（payment state gate）
- 対象: notification/proposal service
- 成果物: `/notifications/send-proposal-atomic`
- 工数: M

8. `SEC-108` n8n接続切替
- 対象: workflow
- 成果物: `Send Proposal Delivery` を atomic APIへ切替
- 工数: S

9. `SEC-109` E2E（Stripe CLI再送・返金競合）試験
- 対象: test automation
- 成果物: 再送/返金レースの自動試験
- 工数: M

## 完了判定（Definition of Done）
1. SEC-101〜109 が完了し、CIでE2Eが安定通過。
2. 監査ログから「誰がいつ承認したか」を追跡できる。
3. 返金後に送信された事例が0件であることを週次検証できる。
