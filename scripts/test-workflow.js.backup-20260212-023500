#!/usr/bin/env node

const fs = require("fs");
const path = require("path");

const requiredFiles = [
  "docs/HP自動生成ワークフロー設計.md",
  "docs/architecture.md",
  "docs/workflow-state-machine.md",
  "n8n/ingest-workflow.json",
  "n8n/stripe-webhook-workflow.json",
  "n8n/analysis-worker-workflow.json",
  "n8n/build-worker-workflow.json",
  "schemas/content-inventory.schema.json"
];

const readJson = (repoRoot, filePath) => {
  const fullPath = path.join(repoRoot, filePath);
  return JSON.parse(fs.readFileSync(fullPath, "utf8"));
};

const findNode = (workflow, name) => workflow.nodes.find((node) => node.name === name);

const findConnectionTargets = (workflow, sourceName, outputIndex = 0) => {
  const source = workflow.connections[sourceName];
  if (!source || !Array.isArray(source.main) || !Array.isArray(source.main[outputIndex])) {
    return [];
  }
  return source.main[outputIndex].map((item) => item.node);
};

const assert = (condition, message) => {
  if (!condition) {
    throw new Error(message);
  }
};

const assertWorkflowShape = (workflow, workflowName) => {
  assert(typeof workflow.name === "string" && workflow.name.length > 0, `${workflowName}: name is required`);
  assert(Array.isArray(workflow.nodes) && workflow.nodes.length > 0, `${workflowName}: nodes are required`);
  assert(
    workflow.connections && typeof workflow.connections === "object",
    `${workflowName}: connections are required`
  );
};

const assertNoPaidPathInIngest = (workflow) => {
  const urls = workflow.nodes
    .filter((node) => node.type === "n8n-nodes-base.httpRequest")
    .map((node) => node.parameters?.url || "");
  const hasPaidQueue = urls.some(
    (url) =>
      /analysis/i.test(url) &&
      !/create-free-comparison|send-preview|checkout-session/i.test(url)
  );
  assert(!hasPaidQueue, "ingest workflow must not include paid analysis path");
};

const assertStripeGate = (workflow) => {
  const gate = findNode(workflow, "If Checkout Completed & Paid?");
  const trigger = findNode(workflow, "Trigger Detailed Analysis Workflow");
  assert(gate, "stripe workflow missing If Checkout Completed & Paid?");
  assert(trigger, "stripe workflow missing Trigger Detailed Analysis Workflow");

  const trueTargets = findConnectionTargets(workflow, "If Checkout Completed & Paid?", 0);
  const falseTargets = findConnectionTargets(workflow, "If Checkout Completed & Paid?", 1);
  assert(
    trueTargets.includes("Mark Paid Status"),
    "stripe workflow true branch must start from Mark Paid Status"
  );
  assert(
    !falseTargets.includes("Trigger Detailed Analysis Workflow"),
    "stripe workflow false branch must not trigger paid analysis"
  );

  const normalizeNode = findNode(workflow, "Normalize Stripe Event");
  const normalizeCode = normalizeNode?.parameters?.jsCode || "";
  assert(
    normalizeCode.includes("checkout.session.completed"),
    "stripe workflow must explicitly gate by checkout.session.completed"
  );
};

const assertAnalysisWorkflow = (workflow) => {
  const requiredWaitNodes = ["Wait R1 Approval", "Wait R2 Approval"];
  requiredWaitNodes.forEach((name) => {
    const node = findNode(workflow, name);
    assert(node, `analysis workflow missing ${name}`);
    assert(node.type === "n8n-nodes-base.wait", `analysis workflow ${name} must be Wait node`);
  });

  const psiMobile = findNode(workflow, "PSI Mobile");
  const psiDesktop = findNode(workflow, "PSI Desktop");
  [psiMobile, psiDesktop].forEach((node, idx) => {
    assert(node, `analysis workflow missing PSI node ${idx + 1}`);
    const params = node.parameters?.queryParameters?.parameters || [];
    const names = new Set(params.map((param) => param.name));
    assert(names.has("url"), `${node.name} must include url query`);
    assert(names.has("strategy"), `${node.name} must include strategy query`);
    assert(names.has("category"), `${node.name} must include category query`);
  });

  const lockGate = findNode(workflow, "If Content Lock OK?");
  assert(lockGate, "analysis workflow missing content lock gate");
  const falseTargets = findConnectionTargets(workflow, "If Content Lock OK?", 1);
  assert(
    falseTargets.includes("Stop Publication (Content Lock Violation)"),
    "analysis workflow must stop publication on content lock violation"
  );
};

const assertBuildWorkflow = (workflow) => {
  const requiredWaitNodes = ["Wait R3 Approval", "Wait R4 Approval"];
  requiredWaitNodes.forEach((name) => {
    const node = findNode(workflow, name);
    assert(node, `build workflow missing ${name}`);
    assert(node.type === "n8n-nodes-base.wait", `build workflow ${name} must be Wait node`);
  });

  const qualityGateNode = findNode(workflow, "If Quality Passed?");
  assert(qualityGateNode, "build workflow missing If Quality Passed?");
  const qualityFalseTargets = findConnectionTargets(workflow, "If Quality Passed?", 1);
  assert(
    qualityFalseTargets.includes("If Retry Remaining?"),
    "build workflow quality NG must go to retry gate"
  );

  const publishTargetsFromQuality = qualityFalseTargets.concat(
    findConnectionTargets(workflow, "If Quality Passed?", 0)
  );
  assert(
    !publishTargetsFromQuality.includes("Send Proposal Delivery"),
    "build workflow must not send delivery directly from quality gate"
  );
};

const main = () => {
  try {
    const repoRoot = path.join(__dirname, "..");
    const missing = requiredFiles.filter((filePath) => {
      const fullPath = path.join(repoRoot, filePath);
      return !fs.existsSync(fullPath);
    });
    if (missing.length > 0) {
      throw new Error(`missing required files: ${missing.join(", ")}`);
    }

    const ingestWorkflow = readJson(repoRoot, "n8n/ingest-workflow.json");
    const stripeWorkflow = readJson(repoRoot, "n8n/stripe-webhook-workflow.json");
    const analysisWorkflow = readJson(repoRoot, "n8n/analysis-worker-workflow.json");
    const buildWorkflow = readJson(repoRoot, "n8n/build-worker-workflow.json");

    assertWorkflowShape(ingestWorkflow, "ingest-workflow");
    assertWorkflowShape(stripeWorkflow, "stripe-webhook-workflow");
    assertWorkflowShape(analysisWorkflow, "analysis-worker-workflow");
    assertWorkflowShape(buildWorkflow, "build-worker-workflow");

    assertNoPaidPathInIngest(ingestWorkflow);
    assertStripeGate(stripeWorkflow);
    assertAnalysisWorkflow(analysisWorkflow);
    assertBuildWorkflow(buildWorkflow);

    process.stdout.write("workflow structure check passed\n");
  } catch (error) {
    fs.writeSync(process.stderr.fd, `test-workflow failed: ${error.message}\n`);
    process.exit(1);
  }
};

main();
